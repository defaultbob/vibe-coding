<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- Cache-busting meta tags -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    
    <title>Multi-Value Chip Input</title>
    <!-- Load Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Use Inter font */
        body {
            font-family: "Inter", sans-serif;
        }
        /* Custom focus style for the wrapper */
        .input-wrapper:focus-within {
            outline: 2px solid #3b82f6; /* blue-500 */
            outline-offset: 2px;
        }
        /* Modal styles */
        .modal {
            transition: opacity 0.25s ease;
        }
        .modal-content {
            transition: transform 0.25s ease;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen py-12">

    <div class="w-full max-w-2xl mx-auto p-6">
        <div class="flex justify-center items-center gap-4 mb-4">
            <h1 class="text-2xl font-semibold text-center text-gray-800">Add Users</h1>
        </div>
        <p class="text-center text-gray-600 mb-6">
            Try pasting: 
            <code class="bg-gray-200 p-1 rounded text-sm">David Mills, Amy Duong, larry.jovanovic@veeva.com</code>
            or a column from Excel:
            <code class="bg-gray-200 p-1 rounded text-sm">David Mills\nAmy Duong\nUnknown Person</code>
        </p>

        <div class="bg-white rounded-lg shadow-md p-4">
            <label for="chip-input" class="text-sm font-medium text-gray-700">Add recipients:</label>
            
            <div id="input-wrapper" class="relative input-wrapper border border-gray-300 rounded-lg p-2 mt-2 flex flex-wrap items-center gap-2 cursor-text" onclick="focusInput()">
                
                <div id="chip-container" class="flex flex-wrap gap-2">
                    <!-- Chips will be added here by JavaScript -->
                </div>

                <input
                    type="text"
                    id="chip-input"
                    class="flex-1 outline-none p-1 min-w-[150px]"
                    placeholder="Type name or username..."
                />

                <button id="copy-button" class="absolute top-2 right-2 p-1 text-gray-400 hover:text-gray-600" title="Copy usernames (Cmd+C)">
                    <svg id="copy-icon-svg" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                      <path stroke-linecap="round" stroke-linejoin="round" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
                    </svg>
                    <svg id="copy-success-svg" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-green-500 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                      <path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" />
                    </svg>
                </button>
            </div>
        </div>

        <!-- Save Button and Message Area -->
        <div class="mt-6 flex flex-col items-center">
            <button id="save-button" class="w-full max-w-xs px-6 py-3 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 transition-colors">
                Save
            </button>
            <div id="message-area" class="mt-4 text-sm h-5 text-center">
                <!-- Validation messages will appear here -->
            </div>
        </div>

        <!-- Display the collected values -->
        <div class="mt-6 bg-gray-50 p-4 rounded-lg shadow-inner">
            <h2 class="font-semibold text-gray-700">Collected Values (User Objects):</h2>
            <pre id="output" class="mt-2 text-sm text-gray-600 overflow-x-auto">[]</pre>
        </div>

        <!-- Requirements Section -->
        <div class="mt-6 bg-white rounded-lg shadow-md">
            <details>
                <summary class="font-semibold text-gray-700 p-6 cursor-pointer">
                    Requirements Supported
                </summary>
                <ul class="list-disc list-inside space-y-2 text-sm text-gray-600 p-6 pt-0">
                    <li>As a user, I can paste a list of recipients separated by commas, semicolons, or newlines (from Excel/Sheets).</li>
                    <li>As a user, I can paste recipients from Gmail/Outlook (e.g., <code class="text-xs">"Name &lt;username&gt;"</code>) and have the app extract just the username.</li>
                    <li>As a user, I can type a single name or username and press Enter to add it.</li>
                    <li>As a user, the app searches for matches by both full name and username.</li>
                    <li>As a user, if my input matches multiple people, I am shown a "wizard" to select the correct person for each ambiguous entry.</li>
                    <li>As a user, if I paste duplicate recipients, the app only adds one.</li>
                    <li>As a user, if my input doesn't match anyone, it appears as a red "unmatched" item.</li>
                    <li>As a user, I am prevented from saving if I have any "unmatched" items, and I see a clear error message.</li>
                    <li>As a user, I can click a copy icon to copy all validated usernames to my clipboard, separated by newlines.</li>
                    <li>As a user, I can press Cmd+C or Ctrl+C to copy all validated usernames, formatted for pasting into Excel rows.</li>
                </ul>
            </details>
        </div>
    </div>

    <!-- Disambiguation Modal -->
    <div id="modal" class="modal fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50 invisible opacity-0">
        <div id="modal-content" class="modal-content bg-white rounded-lg shadow-xl w-full max-w-lg p-6 transform scale-95">
            <h2 class="text-lg font-semibold text-gray-800" id="modal-title">Select a Match</h2>
            <p class="text-sm text-gray-500 mt-1" id="modal-step-counter"></p>
            
            <div class="mt-4 space-y-2 max-h-60 overflow-y-auto" id="modal-options-container">
                <!-- Radio button options will be injected here -->
            </div>

            <div class="mt-6 flex justify-end gap-3">
                <button id="modal-cancel" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300">Cancel</button>
                <button id="modal-confirm" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700">Confirm</button>
            </div>
        </div>
    </div>

    <!-- Template for modal radio options -->
    <template id="modal-option-template">
        <label class="block p-3 border rounded-lg hover:bg-gray-50 cursor-pointer">
            <input type="radio" name="modal-option" class="mr-3">
            <span class="option-name font-medium text-gray-800"></span>
            <span class="option-detail text-sm text-gray-500 ml-1"></span>
        </label>
    </template>


    <script>
        // --- FAKE BACKEND DATA ---
        const fakeDatabase = [
            // Single Matches
            { id: 101, name: "Larry Jovanovic", username: "larry.jovanovic@veeva.com", department: "Engineering" },
            { id: 102, name: "Andy Han", username: "andy.han@veeva.com", department: "Product" },
            { id: 103, name: "Jesse Lund", username: "jesse.lund@veeva.com", department: "Strategy" },

            // 5 David Mills
            { id: 201, name: "David Mills", username: "david.mills@veeva.com", department: "Engineering" },
            { id: 202, name: "David Mills", username: "d.mills@customer.com", department: "Sales (External)" },
            { id: 203, name: "David Mills", username: "david.mills.dev@veeva.com", department: "DevOps" },
            { id: 204, name: "David Mills", username: "dave.millsy@gmail.com", department: "Marketing" },
            { id: 205, name: "David Mills", username: "david@mills-consulting.com", department: "Services (Partner)" },
            
            // 3 Amy Duongs
            { id: 301, name: "Amy Duong", username: "amy.duong@veeva.com", department: "HR" },
            { id: 302, name: "Amy Duong", username: "amy.d@gmail.com", department: "Design (Contractor)" },
            { id: 303, name: "Amy Duong", username: "duong.amy@customer.com", department: "Customer Success" },
        ];

        /**
         * Simulates a backend API call to look up users by name OR username.
         * @param {string[]} inputs - An array of name/username strings.
         * @returns {Promise<object[]>} A promise that resolves with lookup results.
         */
        function fakeBackendLookup(inputs) {
            console.log("Looking up inputs:", inputs);
            return new Promise(resolve => {
                setTimeout(() => {
                    const results = inputs.map(input => {
                        const normalizedInput = input.toLowerCase().trim();
                        
                        // Find matches by username OR name
                        const matches = fakeDatabase.filter(user => 
                            user.username.toLowerCase() === normalizedInput || 
                            user.name.toLowerCase() === normalizedInput
                        );
                        
                        if (matches.length === 1) {
                            return { status: "matched", input: input, data: matches[0] };
                        } else if (matches.length > 1) {
                            return { status: "ambiguous", input: input, matches: matches };
                        } else {
                            return { status: "unmatched", input: input };
                        }
                    });
                    resolve(results);
                }, 500); // Simulate network delay
            });
        }

        // --- DOM ELEMENTS ---
        const chipInput = document.getElementById('chip-input');
        const chipContainer = document.getElementById('chip-container');
        const output = document.getElementById('output');
        const saveButton = document.getElementById('save-button');
        const messageArea = document.getElementById('message-area');
        const copyButton = document.getElementById('copy-button');
        const copyIcon = document.getElementById('copy-icon-svg');
        const copySuccessIcon = document.getElementById('copy-success-svg');
        const inputWrapper = document.getElementById('input-wrapper');
        
        // Modal elements
        const modal = document.getElementById('modal');
        const modalContent = document.getElementById('modal-content');
        const modalTitle = document.getElementById('modal-title');
        const modalStepCounter = document.getElementById('modal-step-counter');
        const modalOptionsContainer = document.getElementById('modal-options-container');
        const modalOptionTemplate = document.getElementById('modal-option-template');
        const modalConfirm = document.getElementById('modal-confirm');
        const modalCancel = document.getElementById('modal-cancel');
        
        let values = []; // Stores the final selected user objects/unmatched inputs
        let currentModalResolver = null; // Stores the 'resolve' function for the modal's promise
        let ambiguousQueue = []; // Queue for the "wizard"
        let totalAmbiguousCount = 0; // For the modal step counter

        // --- CORE FUNCTIONS ---

        function focusInput() {
            chipInput.focus();
        }

        function updateOutput() {
            // Filter only for successfully matched users to show in output
            const matchedUsers = values.filter(v => v.status === 'matched').map(v => v.data);
            output.textContent = JSON.stringify(matchedUsers, null, 2);
        }

        /**
         * Creates a chip in the UI.
         * @param {object} data - The data for the chip (user object or input string).
         * @param {'matched' | 'unmatched'} status - The status of the chip.
         */
        function createChip(data, status) {
            const chipIdentifier = (status === 'matched') ? data.id : data.input;
            
            // Avoid adding duplicates that are already in the list
            if (values.some(v => v.identifier === chipIdentifier)) {
                console.log("Skipping duplicate:", chipIdentifier);
                return;
            }

            // Store an object that tracks status and data
            const valueToStore = {
                identifier: chipIdentifier,
                status: status,
                data: data 
            };
            values.push(valueToStore);
            updateOutput();

            const chip = document.createElement('div');
            chip.dataset.status = status;
            chip.dataset.identifier = chipIdentifier;
            
            let chipTextContent = '';
            
            if (status === 'matched') {
                chip.className = 'chip bg-blue-100 text-blue-800 text-sm font-medium px-3 py-1 rounded-full flex items-center gap-2 animate-fadeIn';
                chipTextContent = data.name; // Display name for matched users
            } else { // 'unmatched'
                chip.className = 'chip bg-red-100 text-red-800 text-sm font-medium px-3 py-1 rounded-full flex items-center gap-2 animate-fadeIn';
                chipTextContent = data.input; // Display the raw input
            }
            
            chip.style.animation = 'fadeIn 0.2s ease-out';

            const chipText = document.createElement('span');
            chipText.textContent = chipTextContent;
            chip.appendChild(chipText);

            const removeButton = document.createElement('button');
            removeButton.className = 'remove-chip font-bold text-lg leading-none';
            removeButton.innerHTML = '&times;';
            removeButton.setAttribute('aria-label', `Remove ${chipTextContent}`);
            
            removeButton.className += (status === 'matched') 
                ? ' text-blue-500 hover:text-blue-700' 
                : ' text-red-500 hover:text-red-700';
            
            removeButton.addEventListener('click', (e) => {
                e.stopPropagation();
                const identifier = chip.dataset.identifier;
                // Remove value from array
                values = values.filter(v => v.identifier != identifier); // Use != for type coercion (id vs string)
                updateOutput();
                chip.remove();
            });

            chip.appendChild(removeButton);
            chipContainer.appendChild(chip);
        }

        /**
         * Shows the modal for ambiguous results and returns a Promise.
         */
        function showDisambiguationModal(result, currentStep, totalSteps) {
            return new Promise((resolve) => {
                currentModalResolver = resolve; // Store the resolver

                modalTitle.textContent = `Select a Match for "${result.input}"`;
                modalStepCounter.textContent = `Resolving ${currentStep} of ${totalSteps}`;
                modalOptionsContainer.innerHTML = ''; // Clear old options

                // Populate options
                result.matches.forEach((match, index) => {
                    const optionClone = modalOptionTemplate.content.cloneNode(true);
                    const input = optionClone.querySelector('input');
                    const nameSpan = optionClone.querySelector('.option-name');
                    const detailSpan = optionClone.querySelector('.option-detail');

                    input.value = JSON.stringify(match); // Store full object
                    if (index === 0) input.checked = true; // Default check
                    
                    nameSpan.textContent = match.name;
                    detailSpan.textContent = `(${match.username} - ${match.department})`;
                    
                    modalOptionsContainer.appendChild(optionClone.firstElementChild);
                });
                modal.classList.remove('invisible', 'opacity-0');
                modalContent.classList.remove('scale-95');
            });
        }

        function hideModal() {
            modal.classList.add('invisible', 'opacity-0');
            modalContent.classList.add('scale-95');
            currentModalResolver = null;
        }

        // --- MODAL EVENT LISTENERS ---
        modalConfirm.addEventListener('click', () => {
            if (currentModalResolver) {
                const selectedInput = modalOptionsContainer.querySelector('input[name="modal-option"]:checked');
                if (selectedInput) {
                    const selectedData = JSON.parse(selectedInput.value);
                    currentModalResolver(selectedData); // Resolve with selected data
                } else {
                    currentModalResolver(null); // Nothing selected
                }
                hideModal();
            }
        });

        modalCancel.addEventListener('click', () => {
            if (currentModalResolver) {
                currentModalResolver(null); // Resolve with null on cancel
            }
            hideModal();
        });

        // --- WIZARD AND LOOKUP LOGIC ---

        /**
         * Processes the ambiguous queue one by one, "wizard" style.
         */
        async function processAmbiguousQueue() {
            if (ambiguousQueue.length === 0) {
                chipInput.disabled = false;
                chipInput.focus();
                console.log("Wizard complete.");
                return; // Wizard is done
            }

            const result = ambiguousQueue.shift(); // Get next item
            const currentStep = totalAmbiguousCount - ambiguousQueue.length;
            const selectedUser = await showDisambiguationModal(result, currentStep, totalAmbiguousCount);
            
            if (selectedUser) {
                // If they confirmed, create a 'matched' chip
                createChip(selectedUser, 'matched');
            } else {
                // If they canceled, create an 'unmatched' chip for the raw input
                createChip({ input: result.input }, 'unmatched');
            }
            
            // Process the next item in the queue
            processAmbiguousQueue();
        }

        /**
         * Main function to process inputs, look them up, and create chips.
         */
        async function lookupAndCreateChips(inputs) {
            if (inputs.length === 0) return;

            chipInput.disabled = true; // Disable input during lookup
            chipInput.placeholder = "Loading...";

            const results = await fakeBackendLookup(inputs);

            // Clear the queue
            ambiguousQueue = [];

            for (const result of results) {
                if (result.status === 'matched') {
                    createChip(result.data, 'matched');
                } else if (result.status === 'unmatched') {
                    createChip({ input: result.input }, 'unmatched');
                } else if (result.status === 'ambiguous') {
                    // Add to the wizard queue
                    ambiguousQueue.push(result);
                }
            }
            
            chipInput.placeholder = "Type name or email...";

            // Start the wizard
            if (ambiguousQueue.length > 0) {
                totalAmbiguousCount = ambiguousQueue.length;
                processAmbiguousQueue(); // This will re-enable the input when done
            } else {
                chipInput.disabled = false; // Re-enable if no wizard
                chipInput.focus();
            }
        }


        // --- INPUT EVENT LISTENERS ---

        chipInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !chipInput.disabled) {
                e.preventDefault();
                const text = chipInput.value.trim();
                if (text) {
                    lookupAndCreateChips([text]);
                    chipInput.value = '';
                }
            }
        });

        chipInput.addEventListener('paste', (e) => {
            if (chipInput.disabled) return;
            e.preventDefault();
            
            const pasteData = e.clipboardData.getData('text/plain');
            
            // Split by comma, semicolon, newline, or tab
            const individualInputs = pasteData.split(/[\n\t,;]+/);
            
            // This regex is good at extracting email-like usernames from formats like "Name <user@name.com>"
            const usernameExtractRegex = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/;

            const valuesToLookup = individualInputs.map(input => {
                const trimmedInput = input.trim();
                if (trimmedInput.length === 0) return null;

                // Check if the string *contains* a username (e.g., "Name <username@...>")
                const usernameMatch = trimmedInput.match(usernameExtractRegex);
                if (usernameMatch) {
                    return usernameMatch[0]; // Extract just the username
                }
                
                // Otherwise, assume it's a name
                return trimmedInput;
            }).filter(Boolean); // Filter out null/empty strings
            
            // "Ignore duplicate pasted names"
            const uniqueValues = [...new Set(valuesToLookup)];
            
            lookupAndCreateChips(uniqueValues);
        });

        // --- COPY FUNCTIONALITY ---

        function copyValuesToClipboard() {
            const matchedUsernames = values
                .filter(v => v.status === 'matched')
                .map(v => v.data.username);
            
            if (matchedUsernames.length === 0) {
                console.log("Nothing to copy.");
                return;
            }

            const textToCopy = matchedUsernames.join('\n');
            
            navigator.clipboard.writeText(textToCopy).then(() => {
                // Show success feedback
                copyIcon.classList.add('hidden');
                copySuccessIcon.classList.remove('hidden');
                setTimeout(() => {
                    copyIcon.classList.remove('hidden');
                    copySuccessIcon.classList.add('hidden');
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy text: ', err);
            });
        }

        copyButton.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent input from focusing
            copyValuesToClipboard();
        });

        inputWrapper.addEventListener('keydown', (e) => {
            // Check for Cmd+C or Ctrl+C
            if ((e.metaKey || e.ctrlKey) && e.key === 'c') {
                e.preventDefault();
                copyValuesToClipboard();
            }
        });

        // --- SAVE BUTTON LISTENER ---
        saveButton.addEventListener('click', () => {
            // Clear any previous message
            messageArea.textContent = '';

            // Find all chips in the DOM with the 'unmatched' status
            const unmatchedChips = chipContainer.querySelectorAll('.chip[data-status="unmatched"]');

            if (unmatchedChips.length > 0) {
                // Validation Error
                messageArea.textContent = 'Error: Please resolve all unmatched recipients before saving.';
                messageArea.className = 'text-red-600 font-medium mt-4 text-center';
            } else {
                // Validation Success
                messageArea.textContent = 'Success! All recipients validated and saved.';
                messageArea.className = 'text-green-600 font-medium mt-4 text-center';
                
                const matchedUsers = values.filter(v => v.status === 'matched').map(v => v.data);
                console.log("Saving values:", matchedUsers);
                // Here you would typically send `matchedUsers` to your real backend
            }

            // Clear the message after 3 seconds
            setTimeout(() => {
                messageArea.textContent = '';
            }, 3000);
        });

        // Add the animation keyframes
        const style = document.createElement('style');
        style.textContent = `
            @keyframes fadeIn {
                from { opacity: 0; transform: scale(0.9); }
                to { opacity: 1; transform: scale(1); }
            }
        `;
        document.head.appendChild(style);
    </script>
</body>
</html>

